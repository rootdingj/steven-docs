Java基础
====================
# 一.数据类型
Java 中的数据类型有两种，基本数据类型和引用数据类型。
- 基本数据类型又称为内置类型，Java保留了基本数据类型，主要是为满足 Java 高效率执行的需求。
- 引用数据类型又称为扩展类型，它的创建是需要去 new 一个对象，该对象的内存分配在堆区，同时栈区会保存一个指向该对象的引用。

## 1、基本类型
| 数据类型    | 大小（bit） | 默认值   | 包装类型   |
| :--------- |:----------:| --------:|----------:|
| byte       | 8          | 0        | Byte      |
| short      | 16         | 0        | Short     | 
| int        | 32         | 0        | Integer   | 
| long       | 64         | 0L       | Long      |
| float      | 32         | 0.0f     | Float     |
| double     | 64         | 0.0d     | Double    |
| char       | 16         | '\u0000' | Character | 
| boolean    | \~         | false    | Boolean   |
| void       | \~         | \~       | Void      |

- 浮点型有 float 、double , 默认数据类型是double。
- boolean 的值为：true、false，JVM会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。boolean 类型的数据可以用1 bit 来存储，但没有明确规定其大小。
- void 表示“没有东西”，如在方法返回值中，表示没有返回值；Void 为 void 的包装类，是一个占位符类，本身不起作用，不能被实例化，多用于泛型中作占位符使用。

- 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用**自动装箱与拆箱**完成。
    ```java
    Integer a = 1;     // 装箱
    int b = a;         // 拆箱
    ```

## 2、引用类型
Java常见的引用类型（对象类型）：类、接口、数组枚举以及字符串等。

如果要判断两个对象是否相同，则需要使用equals()方法，但有一点需要注意：equals()方法的默认行为是比较引用。如果是你自己写的类，你应该为它重写equals()来比较对象的内容。大多数Java类库都实现了比较对象内容的equals()方法。

## 3、缓存池
Integer 中有个静态内部类 IntegerCache ，里面有个 cache[],也就是 Integer 常量池，常量池的大小为一个字节（-128~127）。

new Integer(123) 与 Integer.valueOf(123) 的区别在于：
- new Integer(123) 每次都会新建一个对象；
- Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。

``jdk 1.8`` 源码中
```java
public static Integer valueOf(int i) {
    // 判断是否在缓存池范围中，如果在则返回缓存池中的内容，否则就new Integer() 创建一个新的对象。
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

```

``IntegerCache`` 源码，从中可以知 Integer 默认缓存池的大小范围是 -128~127。
```java
 private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k < cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high >= 127;
        }

        private IntegerCache() {}
    }
```

测试代码
```java
    Integer a = new Integer(123);
    Integer b = new Integer(123);
    System.out.println(a == b);     // false
    Integer x = Integer.valueOf(123);
    Integer y = Integer.valueOf(123);
    System.out.println(x == y);     // true
    // 编译器会在自动装箱过程调用 valueOf() 方法
    Integer n = 123;
    Integer m = 123;
    System.out.println(m == n);     // true
```

# 二、运算

## 1、运算符
运算符按其功能来分，有算术运算符、赋值运算符、关系运算符、逻辑运算符、位运算符等。

## 2、类型转换
数据类型转换分为**隐式类型转换**和**显示类型转换**。  

```text
基本数据类型
低  ------------------------------------>  高

byte,short,char—> int —> long—> float —> double 
```

a、隐式类型转换：小范围的数据类型转为大范围的数据类型称为隐式类型转换或自动类型转换。

- 使用 += 或者 ++ 运算符可以执行隐式类型转换。
```java
short s1 = 1;
// s1 = s1 + 1;  // 1 是 int 类型，不能隐式地将 int 类型下转型为 short 类型

s1 += 1;	  
// 或
s1++;
// 隐式类型转换，相当于 s1 = (short) (s1 + 1);
```

b、显示类型转换：大范围的数据类型转为小范围的数据称为显示类型转换或强制类型转换。
- 显示类型转换可能导致溢出或精度丢失。 

```java
// float f = 1.1;      // 编译不通过，浮点型默认为 double 
float f1 = 1.1f;
float f2 = (float) 1.1;
int i = (int) f1;
System.out.println(i); // 1
```

- 对于 byte、short、char 三种类型而言，他们是相同级别的，因此，不能相互隐式转换，但是可以显示类型转换。char 型向高级类型转换时，会转换成对应的ASCII码值。

```java
short s = 99;
char c = (char) s;
System.out.println(c); // c

byte b = (byte) c;
System.out.println(b); // 99

int n = (int) c;
System.out.println(n); // 99
```

除上述外类型转换还需注意：
    
-  在把大范围的类型转换为小范围的类型时必须使用显示类型转换；
- 引用数据类型的转换需存在继承关系；
- 不能对boolean类型进行类型转换。

# 三、字符串
> String 被声明为 final，因此它不可被继承，它们的值在创建之后不能修改。

## 1、String 源码片段

java.lang.String
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {

/** String的属性值 */  
private final char value[];

/**数组被使用的开始位置**/
private final int offset;

/**String中元素的个数**/
private final int count;

/**String类型的hash值**/
private int hash; // Default to 0

......
```
从源码看出: 
- String 底层使用一个字符数组来维护（Java8）。Java9后使用 byte 数据，可参考 [Java9后String的空间优化](https://blog.csdn.net/wangyangzhizhou/article/details/80371653) 。
- value 数组被 final 修饰，意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，从而保证 String 不可变。

## 2、创建字符串对象两种方式

- **直接赋值**创建的对象是存放在方法区的**常量池**中。
```java
String str="hello";
```

- 通过**构造方法**创建的对象存放在**堆内存**中。
```java
String str=new String("hello");
```

创建字符串的练习：
```java
1、 String str = "123";
```
如上：jvm在编译阶段会判断常量池中是否有 "123" 字面量，如果有，str 直接指向这个字面量的引用，如果没有会在常量池里创建这个字面量。

```java
2、 String str = new String("123");
```
如上：jvm 编译时期判断常量池中 "123" 是否存在，从而判断是否创建字面量，然后运行时期通过 new 关键字在 java heap 中创建 String 对象。

```java
3、 
    String a = "a";
	String b = "b";
    String str = "ab";
    System.out.println(str == "a" + "b"); // true
```
如上：字面量"+"拼接是在编译期间进行的。jvm编译阶段过编译器会把字符串常量直接合并成"123456"，所以创建对象时可能会在常量池中创建1个对象。

```java
    String a = "a";
    String b = "b";
    String str = "ab";
3、 System.out.println(str == "a" + "b"); // true
4、 System.out.println(ab == a + b); // false
```
如上：字面量"+"拼接是在编译期间进行的。jvm编译阶段过编译器会把字符串常量直接合并成"123456"，所以创建对象时可能会在常量池中创建1个对象。
字符串引用的"+"拼接运算实在运行时进行的，新创建的字符串存放在堆中。

## 3、字符串常量池
字符串常量池（String Pool）保存所有字符串字面量（literal strings），这些字面量在编译时期就确定。   

可以使用String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。

```java
String s1 = new String("intern test");
String s2 = new String("intern test");
System.out.println(s1 == s2); // false
String s3 = s1.intern();
String s4 = s1.intern();
System.out.println(s3 == s4); // true
```
如上：当一个字符串调用 intern() 时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法确定），那么就会返回 String Pool 中字符串的引用；否则，会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。

## 4、String, StringBuffer & StringBuilder
**基本区别**：
- String 不可变，因此是线程安全的
- StringBuilder 可变，不是线程安全的
- StringBuffer 可变，是线程安全的，内部使用 synchronized 进行同步

**使用场景**：  
- 在字符串不经常发生变化的业务场景优先使用String。(如常量的声明，少量的字符串操作)

- 在单线程情况下，若有大量的字符串操作情况，应使用 StringBuilder 来操作字符串。使用 String"+"来拼接会产生大量无用的中间对象，耗费空间且执行效率低下。（如封装 JSON 数据）

- 在多线程情况下，若有大量的字符串操作情况，应使用 StringBuffer。（如 HTTP 参数解析和封装）

# 四、面向对象
[面向对象思想](https://blog.csdn.net/dj673344908/article/details/95247363)


# 五、Object 浅读

## 1、源码
```java
 /* 通过JNI对本地方法进行注册，映射本地函数与Java方法之间的关系*/
private static native void registerNatives();   

 /* 在对象初始化时自动调用 registerNatives() */    
static {     
    registerNatives();     
}     

/* 返回此 Object 的运行时类*/   
public final native Class<?> getClass()

/*返回该对象的哈希码值。默认情况下，该方法根据对象的地址来计算哈希码值*/
public native int hashCode()

/*比较两个对象是否同一 */  
public boolean equals(Object obj)

/*本地CLONE方法，用于对象的复制 */  
protected native Object clone() throws CloneNotSupportedException

/*返回该对象的字符串表示*/    
public String toString()

/*唤醒在此对象监视器上等待的单个线程*/ 
public final native void notify()

/*唤醒在此对象监视器上等待的所有线程。*/ 
public final native void notifyAll()

/*在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待*/
public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException

 /*当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法*/    
protected void finalize() throws Throwable {}
```

## 2、hashCode()
hashCode 的通用约定：   
- 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的散列值，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。    
- 如果根据 equals() 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的散列值。    
- 如果根据 equals(t) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不要求一定生成不同的散列值。但是，程序员应该意识到，为不相等的对象生成不同散列值可以提高哈希表的性能。 
- 当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的散列值可。

## 3、equals()
- 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
- 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。
- equals() 具有对称性、自反性、传递性。
- 对任何为 null 的对象调用 x.equals(null) 结果都为 false

## 4、clone()
clone() 有 protected、native 关键字修饰，那么我们需要重写 Object 的 clone() 实现对象的克隆。 

-  浅拷贝
> 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个也会随之变化。
```java
public class Student implements Cloneable {
	// 姓名
	private String name;
	// 年龄
	private int age;
	// 分数
	private Score Score;

	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	public Student(String name, int age, Score score) {
		super();
		this.name = name;
		this.age = age;
		Score = score;
	}

	public Score getScore() {
		return Score;
	}

	public void setScore(Score score) {
		Score = score;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ",mathematics score=" + Score.getMathematics()
				+ ",chinese score=" + Score.getChinese() + "]";
	}

	// 重写Object的clone方法
	public Student clone() throws CloneNotSupportedException {
		return (Student) super.clone();
	}

}

class Score {
	private int mathematics;
	private int chinese;

	public Score(int mathematics, int chinese) {
		super();
		this.mathematics = mathematics;
		this.chinese = chinese;
	}

	public int getMathematics() {
		return mathematics;
	}

	public void setMathematics(int mathematics) {
		this.mathematics = mathematics;
	}

	public int getChinese() {
		return chinese;
	}

	public void setChinese(int chinese) {
		this.chinese = chinese;
	}

}

@Test
public static void testShallowClone() throws CloneNotSupportedException {
	Score score = new Score(99, 90);
	Student orgin = new Student("二牛", 22, score);
	Student clone = orgin.clone();
	System.out.println("orgin：" + orgin.toString());
	System.out.println("clone：" + clone.toString());
	orgin.setName("激动");
	orgin.setAge(1);
	score.setMathematics(100);
	score.setChinese(80);
	System.out.println("orgin：" + orgin.toString());
	System.out.println("clone：" + clone.toString());		
}
```
_clone() 对于基本数据类型、String类型（值传递）为深拷贝，对象、数组等引用类型为浅拷贝。除了**重写 clone() 方法进行浅拷贝**，还可以通过**拷贝构造方法实现浅拷贝**_。

-  深拷贝
> 深拷贝是将对象和值都复制过来，两个对象修改其中任意的值另一个值不会改变。
```java
public class Student implements Cloneable {
	// 姓名
	private String name;
	// 年龄
	private int age;
	// 分数
	private Score Score;

	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	public Student(String name, int age, Score score) {
		super();
		this.name = name;
		this.age = age;
		Score = score;
	}

	public Score getScore() {
		return Score;
	}

	public void setScore(Score score) {
		Score = score;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ",mathematics score=" + Score.getMathematics()
				+ ",chinese score=" + Score.getChinese() + "]";
	}

	// 重写Object的clone方法
	public Student clone() throws CloneNotSupportedException {
        // 拷贝 Student 对象
		Student stu = (Student) super.clone();
		// 拷贝 Student 对象 的score属性
		stu.score = stu.getScore().clone();
		return stu;
	}

}

class Score implements Cloneable {
	private int mathematics;
	private int chinese;

	public Score(int mathematics, int chinese) {
		super();
		this.mathematics = mathematics;
		this.chinese = chinese;
	}

	public int getMathematics() {
		return mathematics;
	}

	public void setMathematics(int mathematics) {
		this.mathematics = mathematics;
	}

	public int getChinese() {
		return chinese;
	}

	public void setChinese(int chinese) {
		this.chinese = chinese;
	}

    // 重写Object类的clone方法
	public ScoreD clone() throws CloneNotSupportedException {
		return (ScoreD) super.clone();
	}

}

@Test
public static void testShallowClone() throws CloneNotSupportedException {
	Score score = new Score(99, 90);
	Student orgin = new Student("二牛", 22, score);
	Student clone = orgin.clone();
	System.out.println("orgin：" + orgin.toString());
	System.out.println("clone：" + clone.toString());
	orgin.setName("激动");
	orgin.setAge(1);
	score.setMathematics(100);
	score.setChinese(80);
	System.out.println("orgin：" + orgin.toString());
	System.out.println("clone：" + clone.toString());		
}
```
_除了重写clone方法来实现深拷贝，还可以通过对象序列化实现深拷贝：将对象序列化为字节序列后，默认会将该对象的整个对象进行序列化，再通过反序列即可实现深拷贝。_

cloneable 是一个标记接口，在实现这个接口的情况下，重写Object中的clone()，然后通过类调用 clone() 才能克隆成功。否则会抛出CloneNotSupportedException。另外，若某个属性被 transient 关键字修饰，那么该属性无法被拷贝。

- clone() 的替代方案
使用 clone() 来拷贝一个对象即复杂又有风险，它会抛出异常，并且需要强制类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。

# 六、反射
每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。

类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 ``Class.forName("com.mysql.jdbc.Driver")`` 这种方式来控制类的加载，该方法会返回一个 Class 对象。

反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。

Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：
- Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；
- Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；
- Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。

**反射的优点**：  
- **可扩展性** ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
- **类浏览器和可视化开发环境** ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
- **调试器和测试工具** ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。

反射的缺点：

尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。

- **性能开销** ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。

- **安全限制** ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。

- **内部暴露** ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

# 七、异常
> Java异常是一个描述在代码段中发生异常的对象，当发生异常情况时，一个代表该异常的对象被创建并且在导致该异常的方法中被抛出，而该方法可以选择自己处理异常或者传递该异常。

## 异常分类
Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常 Exception。

<div align="center"> <img src="images/exception.png" width="520px"> </div><br>

Error : Error 对象由 JVM 生成并抛出，大多数错误与代码编写者所执行的操作无关。它表示不希望被程序捕获或者是程序无法处理的错误。例如，Java虚拟机运行错误（Virtual MachineError），当JVM不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。

Exception ：它表示用户程序可能捕捉的异常情况或者说是程序可以处理的异常。其中 Exception 又分为运行时异常(RuntimeException)和非运行时异常。

- 运行时异常 ：一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；是不受检查异常（Unchecked Exception）。
- 非运行时异常 ：除 RuntimeException 外的 Exception 称为非运行时异常，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。是检查异常（Checked Exception）。

## Java 异常的处理机制
Java的异常处理本质上是抛出异常和捕获异常。

异常处理涉及到五个关键字，分别是：``try、catch、finally、throw、throws``。

## 自定义异常
用户可以通过继承 Exception 类来自定义异常类，更准确的方式是继承运行时异常 RuntimeException 来自定义异常类。

在程序中使用自定义异常类，大体可分为以下几个步骤:
- 创建自定义异常类。
- 在方法中通过 throw 关键字抛出异常对象。
- 如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。
- 在出现异常方法的调用者中捕获并处理异常。

# 八、泛型
> 泛型，即“参数化类型”。即将具体类型参数化，类似于方法中的形参在使用/调用时传入具体的类型（实参）。

泛型的存在的意义：
- 通过泛型的语法定义，编译器可以在编译期提供一定的类型安全检查，过滤掉大部分因为类型不符而导致的运行时异常。
- 泛型可以让程序代码的可读性更高，并且由于本身只是一个语法糖，所以对于 JVM 运行时的性能是没有任何影响的。

泛型可以应用于接口、类和方法中，分别称为泛型接口、泛型类、泛型方法。例如：
```java
public class Generic<T> {
	private T key;

	// 泛型方法
	public <E> void genericMethod(T t){
    		// TODO
	}

	public Generic(T key) {
		super();
		this.key = key;
	}

	public T getKey() {
		return key;
	}

	public void setKey(T key) {
		this.key = key;
	}

	@Override
	public String toString() {
		return "Generic [key=" + key + "]";
	}

}

@Test
public static void testGenericClass() {
	Generic<Integer> integer = new Generic<Integer>(1000);
	System.out.println(integer.toString());
	Generic<String> str = new Generic<String>("Hello Generic");
	System.out.println(str.toString());
	System.out.println("-----------------------");
	List<Integer> list = new ArrayList<Integer>();
	list.add(1);
	list.add(2);
	list.add(3);
	for (Integer n : list) {
		System.out.println(n);
	}
}
```
# 九、注解
[JAVA 注解的基本原理](https://www.cnblogs.com/yangming1996/p/9295168.html)


# 参考：
- [Primitive Data Types](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
- [Integer缓冲池IntegerCache](https://blog.csdn.net/so_geili/article/details/79720238)
- [Java字符串池（String Pool）深度解析](https://www.cnblogs.com/fangfuhai/p/5500065.html)
- [java中Object类 源代码详解](https://www.cnblogs.com/langtianya/archive/2013/01/31/2886572.html)
- [Object类中的registerNatives方法的作用深入介绍](https://blog.csdn.net/Saintyyu/article/details/90452826)
- [Java 浅拷贝和深拷贝的理解和实现方式](https://www.cnblogs.com/shakinghead/p/7651502.html)
- [深入解析Java反射（1） - 基础](https://www.sczyh30.com/posts/Java/java-reflection-1/)
- [Java - 9个处理异常的最佳准则](https://www.cnblogs.com/kcher90/p/7468512.html)
- [泛型的基本原理](https://www.cnblogs.com/yangming1996/p/9199557.html)
- [java泛型详解](https://blog.csdn.net/caihuangshi/article/details/51278793)
- [JAVA 注解的基本原理](https://www.cnblogs.com/yangming1996/p/9295168.html)


